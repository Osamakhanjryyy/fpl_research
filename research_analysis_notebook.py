# -*- coding: utf-8 -*-
"""research_analysis_notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Av7rpHlPc2HwQgEbLwyMUPl23EVS392l
"""

import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import StandardScaler, PowerTransformer
import numpy as np
import matplotlib.pyplot as plt

# Load the dataset
player_hist_stats = pd.read_csv("cleaned_merged_seasons.csv")

# Select relevant features for modeling
features = ['minutes', 'goals_scored', 'assists', 'clean_sheets', 'influence',
            'creativity', 'threat', 'ict_index', 'total_points', 'value']
player_data = player_hist_stats[features].dropna()

# Apply log transformation to skewed features
skewed_features = ['minutes', 'goals_scored', 'assists', 'clean_sheets', 'influence',
                   'creativity', 'threat', 'ict_index']
transformer = PowerTransformer(method='yeo-johnson')
player_data[skewed_features] = transformer.fit_transform(player_data[skewed_features])

# Define the target (total points) and the features for prediction
X = player_data.drop(['total_points'], axis=1)  # Features (independent variables)
y = player_data['total_points']  # Target (dependent variable)

# Split the data into training and test sets for model evaluation
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Initialize and train the XGBoost regressor
xgb_regressor = XGBRegressor(n_estimators=100, random_state=42)
xgb_regressor.fit(X_train, y_train)

# Make predictions
y_pred = xgb_regressor.predict(X_test)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f"Root Mean Squared Error (RMSE): {rmse:.4f}")

# Calculate ROI (points per million cost)
player_data['predicted_points'] = xgb_regressor.predict(scaler.transform(X))
player_data['ROI'] = player_data['predicted_points'] / player_data['value']

# Draft a team based on the highest predicted ROI within budget constraints
budget = 84  # Budget constraint in millions
selected_team = player_data.sort_values(by='ROI', ascending=False).head(11)
team_cost = selected_team['value'].sum()
team_points = selected_team['predicted_points'].sum()

# Ensure that 'name' and 'position' columns exist before printing them
available_columns = selected_team.columns
if 'name' in available_columns and 'position' in available_columns:
    print("\nSelected Team:")
    print(selected_team[['name', 'position', 'predicted_points', 'ROI', 'value']])
else:
    print("\nSelected Team (without name and position columns):")
    print(selected_team[['predicted_points', 'ROI', 'value']])

print(f"\nTotal Team Cost: {team_cost:.2f} million")
print(f"Total Predicted Points for Team: {team_points:.2f}")

# Plot actual vs predicted points for sample players
plt.figure(figsize=(10, 6))
plt.scatter(range(len(y_test)), y_test, color='blue', label='Actual Points')
plt.scatter(range(len(y_pred)), y_pred, color='red', label='Predicted Points')
plt.title('Actual vs Predicted Points')
plt.xlabel('Player Index')
plt.ylabel('Points')
plt.legend()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Group data by team and position, and sum the points
team_position_points = player_hist_stats.groupby(['team_x', 'position'])['total_points'].sum().unstack()

# Calculate the percentage contributions
team_position_percentages = (team_position_points.div(team_position_points.sum(axis=1), axis=0) * 100).fillna(0)

# Plot the grouped bar chart
team_position_percentages.plot(kind='bar', figsize=(16, 8), width=0.8)

# Customize the chart
plt.title('Percentage Contribution of Points from Different Positions for Each Team')
plt.xlabel('Teams')
plt.ylabel('Percentage (%)')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Position', loc='upper right')
plt.grid(axis='y', linestyle='--', alpha=0.5)

plt.show()

import matplotlib.pyplot as plt

# Calculate ROI as total points divided by player value (price)
player_hist_stats['ROI'] = player_hist_stats['total_points'] / player_hist_stats['value']

# Filter data to only include relevant columns and remove NaN or infinite values
roi_data = player_hist_stats[['name', 'value', 'ROI']].dropna()
roi_data = roi_data[roi_data['ROI'].replace([np.inf, -np.inf], np.nan).notna()]

# Sort by ROI and select the top 20 players for better visualization
top_roi_data = roi_data.sort_values(by='ROI', ascending=False).head(20)

# Plot a bar chart for ROI of top 20 players
plt.figure(figsize=(14, 8))
plt.barh(top_roi_data['name'], top_roi_data['ROI'], color='teal')
plt.title('Top 20 Players by Return on Investment (ROI)')
plt.xlabel('ROI (Total Points / Value)')
plt.ylabel('Player Name')
plt.gca().invert_yaxis()  # Invert y-axis to have the highest ROI on top
plt.grid(axis='x', linestyle='--', alpha=0.5)

# Add value labels for each bar
for index, value in enumerate(top_roi_data['ROI']):
    plt.text(value, index, f'{value:.2f}', va='center')

plt.show()

import matplotlib.pyplot as plt

# Filter data for Manchester City players from the dataset
mancity_data = player_hist_stats[player_hist_stats['team_x'] == 'MCI']

# Select features from the Manchester City data for prediction
X_mancity = mancity_data[features]  # Make sure 'features' matches what was used during training
y_mancity_actual = mancity_data['total_points']

# Predict the points using the trained model (no further transformation if already scaled)
y_mancity_predicted = model.predict(X_mancity)

# Plot the actual vs. predicted points for Manchester City
plt.figure(figsize=(14, 8))
plt.plot(mancity_data['GW'], y_mancity_actual, marker='o', label='Actual Points', color='blue')
plt.plot(mancity_data['GW'], y_mancity_predicted, marker='o', linestyle='--', label='Predicted Points', color='red')

plt.title('Actual vs. Predicted Points for Manchester City Players Over Gameweeks')
plt.xlabel('Gameweek')
plt.ylabel('Total Points')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.5)

plt.show()